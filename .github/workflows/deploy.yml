name: Deploy Todo API

on:
  push:
    branches:
      - develop  # → DEV
      - 'release/**'  # → TEST
      - main     # → PROD
  # workflow_dispatch: #Means "manual trigger only" (you click a button to run it)
  # # Alternative triggers:
  #   # push: - runs on git push
  #   # pull_request: - runs on PR creation
  #   # schedule: - runs on a schedule (cron)
  #   inputs:
  #     version:
  #       description: 'Version tag to deploy (e.g., v1.0.0)'
  #       required: true
  #       type: string
  #     environment:
  #       description: 'Target environment'
  #       required: true
  #       type: choice # Dropdown menu (not free text)
  #       options:
  #         - dev
  #         - test
  #         - prod

jobs:
  deploy: # A workflow can have multiple jobs (we have one: deploy). Name of this job (you can call it anything)
    name: Deploy to Azure # Display name for the job
    runs-on: ubuntu-latest # GitHub provides hosted runners (virtual machines)
    environment: >-
      ${{
        (github.ref == 'refs/heads/main' && 'prod') ||
        (startsWith(github.ref, 'refs/heads/release/') && 'test') ||
        'dev'
      }}
    
    steps:
      # Step 0: 
      - name: Determine environment
        id: set-env
        run: |
          if [[ "${GITHUB_REF}" == "refs/heads/main" ]]; then
            ENV="prod"
          elif [[ "${GITHUB_REF}" == refs/heads/release/* ]]; then
            ENV="test"
          elif [[ "${GITHUB_REF}" == "refs/heads/develop" ]]; then
            ENV="dev"
          else
            echo "Error: Cannot deploy from branch ${GITHUB_REF}"
            echo "Allowed branches: develop, release/*, main"
            exit 1
          fi
          
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "Deploying to: ${ENV}"

      # Step 1: Checkout code
      # Downloads your repository code into the runner (VM), Like doing git clone + git checkout v1.0.0
      - name: Checkout code 
      # Uses a pre-built action from GitHub marketplace
        uses: actions/checkout@v4
        with:
          # ref: ${{ inputs.version }}
          ref: ${{ github.ref }}
      
      # Step 2: Set up Python
      # Installs Python 3.11 on the runner, Like running apt-get install python3.11
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      # Step 3: Install dependencies
      - name: Install dependencies
      # The | means "multi-line string"
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      # Step 4: Run tests
      - name: Run tests
      # If tests fail, workflow stops here (deployment blocked)
        run: |
          pip install pytest
          pytest tests/ -v

      # Step 5: Get version from code
      - name: Get version
        id: version
        run: |
          VERSION=$(grep "VERSION = " app/config.py | cut -d'"' -f2)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Deploying version: $VERSION"
      
      # Step 5: Azure Login
      # Authenticates with Azure using Service Principal. Like running az login but with automation credentials
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_SERV_PRINCIPAL }}
      
      # Step 6: Set up Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
      
      # Step 7: Terraform Init
      # Installs Terraform CLI. Like downloading from terraform.io
      - name: Terraform Init
        working-directory: ./terraform #Like doing cd terraform && terraform init
        run: terraform init
      
      # Step 8: Terraform Plan
      - name: Terraform Plan
        working-directory: ./terraform
        run: |
          terraform plan \
            -var="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
            -var="environment=${{ steps.set-env.outputs.environment }}" \
            -var="app_version=${{ steps.version.outputs.version }}" \
            -out=tfplan
      
      # Step 9: Terraform Apply
      - name: Terraform Apply
        working-directory: ./terraform
        run: terraform apply -auto-approve tfplan
      
      # Step 10: Get App Service name from Terraform output
      - name: Get App Service Name
        id: terraform-output
        working-directory: ./terraform
        # Gets the output value we defined in `outputs.tf`. `-raw` means no quotes, just the value
        # Stores the value in a special file
        run: |
          APP_NAME=$(terraform output -raw app_service_name)
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
      
      # Step 11: Deploy to Azure App Service
      - name: Deploy to Azure App Service
        uses: azure/webapps-deploy@v2
        with:
        # References Step 10's output. Here, steps.terraform-output - the step ID
          app-name: ${{ steps.terraform-output.outputs.app_name }}
          # What to deploy. Here . means current directory (your entire repo). Azure will detect it's a Python app and run it
          package: .
      
      # Step 12: Update deployment history
      # Appends deployment record to deployment-history.md file. >>  means append to file (don't overwrite)
      - name: Update Deployment History
        run: |
          echo "## $(date '+%Y-%m-%d %H:%M:%S')" >> deployment-history.md
          echo "- **${{ steps.set-env.outputs.environment }}**: Deployed ${{ steps.version.outputs.version }}" >> deployment-history.md
          echo "" >> deployment-history.md
      
      # Step 13: Commit deployment history (optional)
      # Commits the updated deployment-history.md. Pushes it back to GitHub
      - name: Commit deployment history
        continue-on-error: true
        # "If no changes, skip commit; otherwise commit"
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add deployment-history.md
          git diff --quiet && git diff --staged --quiet || git commit -m "Update deployment history: ${{ steps.set-env.outputs.environment }} -> ${{ steps.version.outputs.version }}"
          git push